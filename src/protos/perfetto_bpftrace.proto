// This was taken from https://github.com/google/perfetto/blob/main/protos/perfetto/trace/perfetto_trace.proto

// AUTOGENERATED - DO NOT EDIT
// ---------------------------
// This file has been generated by
// AOSP://external/perfetto/tools/gen_merged_protos
// merging the perfetto config protos.
// This fused proto is intended to be copied in:
//  - Android tree, for statsd.
//  - Google internal repos.

syntax = "proto2";

package perfetto.protos;

option go_package = "github.com/google/perfetto/perfetto_proto";

// Begin of protos/perfetto/common/track_event_descriptor.proto

message TrackEventCategory {
  optional string name = 1;
  optional string description = 2;
  repeated string tags = 3;
}

message TrackEventDescriptor {
  repeated TrackEventCategory available_categories = 1;
}

// End of protos/perfetto/common/track_event_descriptor.proto

// Begin of protos/perfetto/common/data_source_descriptor.proto

// This message is sent from Producer(s) to the tracing Service when registering
// to advertise their capabilities. It describes the structure of tracing
// protos that will be produced by the data source and the supported filters.
message DataSourceDescriptor {
  // e.g., "linux.ftrace", "chromium.tracing"
  optional string name = 1;

  // When non-zero, this is a unique ID within the scope of the Producer for
  // this data source (it is NOT globally unique). This is useful to
  // differentiate between data sources with matching names when calling
  // UpdateDataSource(). This field has been introduced in November 2021
  // (v22, Android T) and is not supported on older versions.
  optional uint64 id = 7;

  // When true the data source is expected to ack the stop request through the
  // NotifyDataSourceStopped() IPC. This field has been introduced after
  // Android P in Jul 2018 and is not supported on older versions.
  optional bool will_notify_on_stop = 2;

  // When true the data source is expected to ack the start request through the
  // NotifyDataSourceStarted() IPC. This field has been introduced after
  // Android P in March 2019 and is not supported on older versions.
  optional bool will_notify_on_start = 3;

  // If true, opt into receiving the ClearIncrementalState() IPC. This should be
  // set if the data source writes packets that refer to previous trace
  // contents, and knows how to stop referring to the already-emitted data.
  optional bool handles_incremental_state_clear = 4;

  // If true, indicates that the data source does nothing upon Flush. This
  // allows the service to reduce the flush-related IPC traffic and better deal
  // with frozen producers (see go/perfetto-frozen). This is usually the case
  // for data sources like 'track_event' that don't have access to the various
  // thread task runners to post a flush task and rely purely on server-side
  // scraping.
  // Introduced in v39 / Android V.
  optional bool no_flush = 9;

  optional TrackEventDescriptor track_event_descriptor = 6 [lazy = true];
}

// End of protos/perfetto/common/data_source_descriptor.proto

// Begin of protos/perfetto/common/builtin_clock.proto

enum BuiltinClock {
  BUILTIN_CLOCK_UNKNOWN = 0;
  BUILTIN_CLOCK_REALTIME = 1;
  BUILTIN_CLOCK_REALTIME_COARSE = 2;
  BUILTIN_CLOCK_MONOTONIC = 3;
  BUILTIN_CLOCK_MONOTONIC_COARSE = 4;
  BUILTIN_CLOCK_MONOTONIC_RAW = 5;
  BUILTIN_CLOCK_BOOTTIME = 6;
  BUILTIN_CLOCK_TSC = 9;
  BUILTIN_CLOCK_MAX_ID = 63;

  reserved 7, 8;
}

// End of protos/perfetto/common/builtin_clock.proto

// Begin of protos/perfetto/config/android/android_game_intervention_list_config.proto

// End of protos/perfetto/config/android/android_game_intervention_list_config.proto

// Begin of protos/perfetto/config/android/packages_list_config.proto

// Data source that lists details (such as version code) about packages on an
// Android device.
message PackagesListConfig {
  // If not empty, emit info about only the following list of package names
  // (exact match, no regex). Otherwise, emit info about all packages.
  repeated string package_name_filter = 1;
}

// End of protos/perfetto/config/android/packages_list_config.proto

// Begin of protos/perfetto/common/protolog_common.proto

enum ProtoLogLevel {
  PROTOLOG_LEVEL_UNDEFINED = 0;
  PROTOLOG_LEVEL_DEBUG = 1;
  PROTOLOG_LEVEL_VERBOSE = 2;
  PROTOLOG_LEVEL_INFO = 3;
  PROTOLOG_LEVEL_WARN = 4;
  PROTOLOG_LEVEL_ERROR = 5;
  PROTOLOG_LEVEL_WTF = 6;
}
// End of protos/perfetto/common/protolog_common.proto

// Begin of protos/perfetto/config/android/protolog_config.proto

// Custom configuration for the "android.protolog" data source.
// ProtoLog is a logging mechanism that is intented to be more efficient than
// logcat. This configures what logs to capture in the tracing instance.
message ProtoLogConfig {
  enum TracingMode {
    // When using the DEFAULT tracing mode, only log groups and levels specified
    // in the group_overrides are traced.
    DEFAULT = 0;
    // When using the ENABLE_ALL tracing mode, all log groups and levels are
    // traced, unless specified in the group_overrides.
    ENABLE_ALL = 1;
  }

  // Specified the configurations for each of the logging groups. If none is
  // specified for a group the defaults will be used.
  repeated ProtoLogGroup group_overrides = 1;
  // Specified what tracing mode to use for the tracing instance.
  optional TracingMode tracing_mode = 2;
}

message ProtoLogGroup {
  // The ProtoLog group name this configuration entry applies to.
  optional string group_name = 1;
  // Specify the level from which to start capturing protologs.
  // e.g. if ProtoLogLevel.WARN is specified only warning, errors and fatal log
  // message will be traced.
  optional ProtoLogLevel log_from = 2;
  // When set to true we will collect the stacktrace for each protolog message
  // in this group that we are tracing.
  optional bool collect_stacktrace = 3;
}

// End of protos/perfetto/config/android/protolog_config.proto

// Begin of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Custom configuration for the "android.surfaceflinger.layers" data source.
message SurfaceFlingerLayersConfig {
  enum Mode {
    MODE_UNSPECIFIED = 0;

    // Trace layers snapshots. A snapshot is taken every time a layers change
    // occurs.
    MODE_ACTIVE = 1;

    // Generate layers snapshots from the transactions kept in the
    // SurfaceFlinger's internal ring buffer.
    // The layers snapshots generation occurs when this data source is flushed.
    MODE_GENERATED = 2;

    // Trace a single layers snapshot.
    MODE_DUMP = 3;

    // Default mode (applied by SurfaceFlinger if no mode is specified).
    // Same as MODE_GENERATED, but triggers the layers snapshots generation only when a bugreport
    // is taken.
    MODE_GENERATED_BUGREPORT_ONLY = 4;
  }
  optional Mode mode = 1;

  enum TraceFlag {
    TRACE_FLAG_UNSPECIFIED = 0;
    TRACE_FLAG_INPUT = 0x02;
    TRACE_FLAG_COMPOSITION = 0x04;
    TRACE_FLAG_EXTRA = 0x08;
    TRACE_FLAG_HWC = 0x10;
    TRACE_FLAG_BUFFERS = 0x20;
    TRACE_FLAG_VIRTUAL_DISPLAYS = 0x40;

    // INPUT | COMPOSITION | EXTRA
    TRACE_FLAG_ALL = 0x0e;
  }
  repeated TraceFlag trace_flags = 2;
}

// End of protos/perfetto/config/android/surfaceflinger_layers_config.proto

// Begin of protos/perfetto/common/perf_events.proto

// Next id: 12
message PerfEvents {
  // What event to sample on, and how often. Commented from the perspective of
  // its use in |PerfEventConfig|.
  message Timebase {
    // How often the per-cpu sampling will occur. Not guaranteed to be honored
    // as the kernel can throttle the sampling rate if it's too high.
    // If unset, an implementation-defined default is used.
    oneof interval {
      // Per-cpu sampling frequency in Hz, as requested from the kernel. Not the
      // same as 1/period.
      // Details: the actual sampling will still be based on a period, but the
      // kernel will dynamically adjust it based on the observed event rate, to
      // approximate this frequency. Works best with steady-rate events like
      // timers.
      uint64 frequency = 2;

      // Per-cpu sampling will occur every |period| counts of |event|.
      // Prefer |frequency| by default, as it's easier to oversample with a
      // fixed period.
      uint64 period = 1;
    }

    // Counting event to use as a timebase for the sampling.
    // If unset, implies the CPU timer (SW_CPU_CLOCK) as the event,
    // which is what you usually want.
    // See common/perf_events.proto for the definitions.
    oneof event {
      Counter counter = 4;
      Tracepoint tracepoint = 3;
      RawEvent raw_event = 5;
    }

    // If set, samples will be timestamped with the given clock.
    // If unset, the clock is chosen by the implementation.
    // For software events, prefer PERF_CLOCK_BOOTTIME. However it cannot be
    // used for hardware events (due to interrupt safety), for which the
    // recommendation is to use one of the monotonic clocks.
    optional PerfClock timestamp_clock = 11;

    // Optional arbitrary name for the event, to identify it in the parsed
    // trace. Does *not* affect the profiling itself. If unset, the trace
    // parser will choose a suitable name.
    optional string name = 10;
  }

  // Builtin counter names from the uapi header. Commented with their perf tool
  // aliases.
  // TODO(rsavitski): consider generating enums for cache events (should be
  // finite), and generally make this list as extensive as possible. Excluding
  // things like dynamic PMUs since those don't fit into a static enum.
  // Next id: 21
  enum Counter {
    UNKNOWN_COUNTER = 0;

    // cpu-clock
    SW_CPU_CLOCK = 1;
    // page-faults, faults
    SW_PAGE_FAULTS = 2;
    // task-clock
    SW_TASK_CLOCK = 3;
    // context-switches, cs
    SW_CONTEXT_SWITCHES = 4;
    // cpu-migrations, migrations
    SW_CPU_MIGRATIONS = 5;
    // minor-faults
    SW_PAGE_FAULTS_MIN = 6;
    // major-faults
    SW_PAGE_FAULTS_MAJ = 7;
    // alignment-faults
    SW_ALIGNMENT_FAULTS = 8;
    // emulation-faults
    SW_EMULATION_FAULTS = 9;
    // dummy
    SW_DUMMY = 20;

    // cpu-cycles, cycles
    HW_CPU_CYCLES = 10;
    // instructions
    HW_INSTRUCTIONS = 11;
    // cache-references
    HW_CACHE_REFERENCES = 12;
    // cache-misses
    HW_CACHE_MISSES = 13;
    // branch-instructions, branches
    HW_BRANCH_INSTRUCTIONS = 14;
    // branch-misses
    HW_BRANCH_MISSES = 15;
    // bus-cycles
    HW_BUS_CYCLES = 16;
    // stalled-cycles-frontend, idle-cycles-frontend
    HW_STALLED_CYCLES_FRONTEND = 17;
    // stalled-cycles-backend, idle-cycles-backend
    HW_STALLED_CYCLES_BACKEND = 18;
    // ref-cycles
    HW_REF_CPU_CYCLES = 19;
  }

  message Tracepoint {
    // Group and name for the tracepoint, acceptable forms:
    // * "sched/sched_switch"
    // * "sched:sched_switch"
    optional string name = 1;

    // Optional field-level filter for the tracepoint. Only events matching this
    // filter will be counted (and therefore contribute to the sampling period).
    // Example: "prev_pid >= 42 && next_pid == 0".
    // For full syntax, see kernel documentation on "Event filtering":
    // https://www.kernel.org/doc/Documentation/trace/events.txt
    optional string filter = 2;
  }

  // Syscall-level description of the event, propagated to the perf_event_attr
  // struct. Primarily for local use-cases, since the event availability and
  // encoding is hardware-specific.
  message RawEvent {
    optional uint32 type = 1;
    optional uint64 config = 2;
    optional uint64 config1 = 3;
    optional uint64 config2 = 4;
  }

  // Subset of clocks that is supported by perf timestamping.
  // CLOCK_TAI is excluded since it's not expected to be used in practice, but
  // would require additions to the trace clock synchronisation logic.
  enum PerfClock {
    UNKNOWN_PERF_CLOCK = 0;
    PERF_CLOCK_REALTIME = 1;
    PERF_CLOCK_MONOTONIC = 2;
    PERF_CLOCK_MONOTONIC_RAW = 3;
    PERF_CLOCK_BOOTTIME = 4;
  }
}

// End of protos/perfetto/common/perf_events.proto

// Begin of protos/perfetto/trace/clock_snapshot.proto

// A snapshot of clock readings to allow for trace alignment.
message ClockSnapshot {
  message Clock {
    // DEPRECATED. This enum has moved to ../common/builtin_clock.proto.
    enum BuiltinClocks {
      UNKNOWN = 0;
      REALTIME = 1;
      REALTIME_COARSE = 2;
      MONOTONIC = 3;
      MONOTONIC_COARSE = 4;
      MONOTONIC_RAW = 5;
      BOOTTIME = 6;
      BUILTIN_CLOCK_MAX_ID = 63;

      reserved 7, 8;
    }

    // Clock IDs have the following semantic:
    // [1, 63]:    Builtin types, see BuiltinClock from
    //             ../common/builtin_clock.proto.
    // [64, 127]:  User-defined clocks. These clocks are sequence-scoped. They
    //             are only valid within the same |trusted_packet_sequence_id|
    //             (i.e. only for TracePacket(s) emitted by the same TraceWriter
    //             that emitted the clock snapshot).
    // [128, MAX]: Reserved for future use. The idea is to allow global clock
    //             IDs and setting this ID to hash(full_clock_name) & ~127.
    optional uint32 clock_id = 1;

    // Absolute timestamp. Unit is ns unless specified otherwise by the
    // unit_multiplier_ns field below.
    optional uint64 timestamp = 2;

    // When true each TracePacket's timestamp should be interpreted as a delta
    // from the last TracePacket's timestamp (referencing this clock) emitted by
    // the same packet_sequence_id. Should only be used for user-defined
    // sequence-local clocks. The first packet timestamp after each
    // ClockSnapshot that contains this clock is relative to the |timestamp| in
    // the ClockSnapshot.
    optional bool is_incremental = 3;

    // Allows to specify a custom unit different than the default (ns) for this
    // clock domain. A multiplier of 1000 means that a timestamp = 3 should be
    // interpreted as 3000 ns = 3 us. All snapshots for the same clock within a
    // trace need to use the same unit.
    optional uint64 unit_multiplier_ns = 4;
  }
  repeated Clock clocks = 1;

  // The authoritative clock domain for the trace. Defaults to BOOTTIME, but can
  // be overridden in TraceConfig's builtin_data_sources. Trace processor will
  // attempt to translate packet/event timestamps from various data sources (and
  // their chosen clock domains) to this domain during import.
  optional BuiltinClock primary_trace_clock = 2;
}

// End of protos/perfetto/trace/clock_snapshot.proto

// Begin of protos/perfetto/common/descriptor.proto

// The protocol compiler can output a FileDescriptorSet containing the .proto
// files it parses.
message FileDescriptorSet {
  repeated FileDescriptorProto file = 1;
}

// Describes a complete .proto file.
message FileDescriptorProto {
  // file name, relative to root of source tree
  optional string name = 1;
  // e.g. "foo", "foo.bar", etc.
  optional string package = 2;

  // Names of files imported by this file.
  repeated string dependency = 3;
  // Indexes of the public imported files in the dependency list above.
  repeated int32 public_dependency = 10;
  // Indexes of the weak imported files in the dependency list.
  // For Google-internal migration only. Do not use.
  repeated int32 weak_dependency = 11;

  // All top-level definitions in this file.
  repeated DescriptorProto message_type = 4;
  repeated EnumDescriptorProto enum_type = 5;
  repeated FieldDescriptorProto extension = 7;

  reserved 6;
  reserved 8;
  reserved 9;
  reserved 12;
}

// Describes a message type.
message DescriptorProto {
  optional string name = 1;

  repeated FieldDescriptorProto field = 2;
  repeated FieldDescriptorProto extension = 6;

  repeated DescriptorProto nested_type = 3;
  repeated EnumDescriptorProto enum_type = 4;

  reserved 5;

  repeated OneofDescriptorProto oneof_decl = 8;

  reserved 7;

  // Range of reserved tag numbers. Reserved tag numbers may not be used by
  // fields or extension ranges in the same message. Reserved ranges may
  // not overlap.
  message ReservedRange {
    // Inclusive.
    optional int32 start = 1;
    // Exclusive.
    optional int32 end = 2;
  }
  repeated ReservedRange reserved_range = 9;
  // Reserved field names, which may not be used by fields in the same message.
  // A given name may only be reserved once.
  repeated string reserved_name = 10;
}

// A message representing a option the parser does not recognize. This only
// appears in options protos created by the compiler::Parser class.
// DescriptorPool resolves these when building Descriptor objects. Therefore,
// options protos in descriptor objects (e.g. returned by Descriptor::options(),
// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
// in them.
message UninterpretedOption {
  // The name of the uninterpreted option.  Each string represents a segment in
  // a dot-separated name.  is_extension is true iff a segment represents an
  // extension (denoted with parentheses in options specs in .proto files).
  // E.g.,{ ["foo", false], ["bar.baz", true], ["moo", false] } represents
  // "foo.(bar.baz).moo".
  message NamePart {
    optional string name_part = 1;
    optional bool is_extension = 2;
  }
  repeated NamePart name = 2;

  // The value of the uninterpreted option, in whatever type the tokenizer
  // identified it as during parsing. Exactly one of these should be set.
  optional string identifier_value = 3;
  optional uint64 positive_int_value = 4;
  optional int64 negative_int_value = 5;
  optional double double_value = 6;
  optional bytes string_value = 7;
  optional string aggregate_value = 8;
}

message FieldOptions {
  // The packed option can be enabled for repeated primitive fields to enable
  // a more efficient representation on the wire. Rather than repeatedly
  // writing the tag and type for each element, the entire array is encoded as
  // a single length-delimited blob. In proto3, only explicit setting it to
  // false will avoid using packed encoding.
  optional bool packed = 2;

  // The parser stores options it doesn't recognize here. See above.
  repeated UninterpretedOption uninterpreted_option = 999;
}

// Describes a field within a message.
message FieldDescriptorProto {
  enum Type {
    // 0 is reserved for errors.
    // Order is weird for historical reasons.
    TYPE_DOUBLE = 1;
    TYPE_FLOAT = 2;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
    // negative values are likely.
    TYPE_INT64 = 3;
    TYPE_UINT64 = 4;
    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
    // negative values are likely.
    TYPE_INT32 = 5;
    TYPE_FIXED64 = 6;
    TYPE_FIXED32 = 7;
    TYPE_BOOL = 8;
    TYPE_STRING = 9;
    // Tag-delimited aggregate.
    // Group type is deprecated and not supported in proto3. However, Proto3
    // implementations should still be able to parse the group wire format and
    // treat group fields as unknown fields.
    TYPE_GROUP = 10;
    // Length-delimited aggregate.
    TYPE_MESSAGE = 11;

    // New in version 2.
    TYPE_BYTES = 12;
    TYPE_UINT32 = 13;
    TYPE_ENUM = 14;
    TYPE_SFIXED32 = 15;
    TYPE_SFIXED64 = 16;
    // Uses ZigZag encoding.
    TYPE_SINT32 = 17;
    // Uses ZigZag encoding.
    TYPE_SINT64 = 18;
  };

  enum Label {
    // 0 is reserved for errors
    LABEL_OPTIONAL = 1;
    LABEL_REQUIRED = 2;
    LABEL_REPEATED = 3;
  };

  optional string name = 1;
  optional int32 number = 3;
  optional Label label = 4;

  // If type_name is set, this need not be set.  If both this and type_name
  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
  optional Type type = 5;

  // For message and enum types, this is the name of the type.  If the name
  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
  // rules are used to find the type (i.e. first the nested types within this
  // message are searched, then within the parent, on up to the root
  // namespace).
  optional string type_name = 6;

  // For extensions, this is the name of the type being extended.  It is
  // resolved in the same manner as type_name.
  optional string extendee = 2;

  // For numeric types, contains the original text representation of the value.
  // For booleans, "true" or "false".
  // For strings, contains the default text contents (not escaped in any way).
  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
  // TODO(kenton):  Base-64 encode?
  optional string default_value = 7;

  optional FieldOptions options = 8;

  // If set, gives the index of a oneof in the containing type's oneof_decl
  // list.  This field is a member of that oneof.
  optional int32 oneof_index = 9;

  reserved 10;
}

// Describes a oneof.
message OneofDescriptorProto {
  optional string name = 1;
  optional OneofOptions options = 2;
}

// Describes an enum type.
message EnumDescriptorProto {
  optional string name = 1;

  repeated EnumValueDescriptorProto value = 2;

  reserved 3;
  reserved 4;

  // Reserved enum value names, which may not be reused. A given name may only
  // be reserved once.
  repeated string reserved_name = 5;
}

// Describes a value within an enum.
message EnumValueDescriptorProto {
  optional string name = 1;
  optional int32 number = 2;

  reserved 3;
}

message OneofOptions {
  reserved 999;

  // Clients can define custom options in extensions of this message. See above.
  extensions 1000 to max;
}

// End of protos/perfetto/common/descriptor.proto

// Begin of protos/perfetto/trace/extension_descriptor.proto

// This message contains descriptors used to parse extension fields of
// TrackEvent.
//
// See docs/design-docs/extensions.md for more details.
message ExtensionDescriptor {
  optional FileDescriptorSet extension_set = 1;
}

// End of protos/perfetto/trace/extension_descriptor.proto

// Begin of protos/perfetto/trace/filesystem/inode_file_map.proto

// Represents the mapping between inode numbers in a block device and their path
// on the filesystem
message InodeFileMap {
  // Representation of Entry
  message Entry {
    optional uint64 inode_number = 1;

    // The path to the file, e.g. "etc/file.xml"
    // List of strings for multiple hardlinks
    repeated string paths = 2;

    // The file type
    enum Type {
      UNKNOWN = 0;
      FILE = 1;
      DIRECTORY = 2;
    }
    optional Type type = 3;
  }

  optional uint64 block_device_id = 1;

  // The mount points of the block device, e.g. ["system"].
  repeated string mount_points = 2;

  // The list of all the entries from the block device
  repeated Entry entries = 3;
}

// End of protos/perfetto/trace/filesystem/inode_file_map.proto

// Begin of protos/perfetto/trace/profiling/profile_common.proto

// TODO(fmayer): Figure out naming thoroughout this file to get a
// nomenclature that works between Windows and Linux.

// The interning fields in this file can refer to 2 different intern tables,
// depending on the message they are used in. If the interned fields are present
// in ProfilePacket proto, then the intern tables included in the ProfilePacket
// should be used. If the intered fields are present in the
// StreamingProfilePacket proto, then the intern tables included in all of the
// previous InternedData message with same sequence ID should be used.
// TODO(fmayer): Move to the intern tables to a common location.
message InternedString {
  optional uint64 iid = 1;
  optional bytes str = 2;
}

// A symbol field that is emitted after the trace is written. These tables would
// be appended as the last packets in the trace that the profiler will use, so
// that the actual trace need not be rewritten to symbolize the profiles.
message ProfiledFrameSymbols {
  // Use the frame id as the interning key for the symbols.
  optional uint64 frame_iid = 1;

  // These are repeated because when inlining happens, multiple functions'
  // frames can be at a single address. Imagine function Foo calling the
  // std::vector<int> constructor, which gets inlined at 0xf00. We then get
  // both Foo and the std::vector<int> constructor when we symbolize the
  // address.

  // key to InternedString
  repeated uint64 function_name_id = 2;

  // key to InternedString
  repeated uint64 file_name_id = 3;

  repeated uint32 line_number = 4;
}

message Line {
  optional string function_name = 1;
  optional string source_file_name = 2;
  optional uint32 line_number = 3;
}

// Symbols for a given address in a module.
message AddressSymbols {
  optional uint64 address = 1;

  // Source lines that correspond to this address.
  //
  // These are repeated because when inlining happens, multiple functions'
  // frames can be at a single address. Imagine function Foo calling the
  // std::vector<int> constructor, which gets inlined at 0xf00. We then get
  // both Foo and the std::vector<int> constructor when we symbolize the
  // address.
  repeated Line lines = 2;
}

// Symbols for addresses seen in a module.
message ModuleSymbols {
  // Fully qualified path to the mapping.
  // E.g. /system/lib64/libc.so.
  optional string path = 1;

  // .note.gnu.build-id on Linux (not hex encoded).
  // uuid on MacOS.
  // Module GUID on Windows.
  optional string build_id = 2;
  repeated AddressSymbols address_symbols = 3;
}

message Mapping {
  // Interning key.
  optional uint64 iid = 1;

  // Interning key.
  optional uint64 build_id = 2;

  // The linker may create multiple memory mappings for the same shared
  // library.
  // This is so that the ELF header is mapped as read only, while the
  // executable memory is mapped as executable only.
  // The details of this depend on the linker, a possible mapping of an ELF
  // file is this:
  //         +----------------------+
  // ELF     |xxxxxxxxxyyyyyyyyyyyyy|
  //         +---------+------------+
  //         |         |
  //         | read    | executable
  //         v mapping v mapping
  //         +----------------------+
  // Memory  |xxxxxxxxx|yyyyyyyyyyyy|
  //         +------------------+---+
  //         ^         ^        ^
  //         +         +        +
  //       start     exact    relpc
  //       offset   offset    0x1800
  //       0x0000   0x1000
  //
  // exact_offset is the offset into the library file of this mapping.
  // start_offset is the offset into the library file of the first mapping
  // for that library. For native libraries (.so files) this should be 0.

  // This is not set on Android 10.
  optional uint64 exact_offset = 8;

  optional uint64 start_offset = 3;
  optional uint64 start = 4;
  optional uint64 end = 5;
  optional uint64 load_bias = 6;

  // E.g. ["system", "lib64", "libc.so"]
  // id of string.
  repeated uint64 path_string_ids = 7;
}

message Frame {
  // Interning key
  optional uint64 iid = 1;

  // E.g. "fopen"
  // id of string.
  optional uint64 function_name_id = 2;

  optional uint64 mapping_id = 3;
  optional uint64 rel_pc = 4;
}

message Callstack {
  optional uint64 iid = 1;
  // Frames of this callstack. Bottom frame first.
  repeated uint64 frame_ids = 2;
}

// End of protos/perfetto/trace/profiling/profile_common.proto

// Begin of protos/perfetto/trace/track_event/chrome_histogram_sample.proto

message HistogramName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/chrome_histogram_sample.proto

// Begin of protos/perfetto/trace/track_event/debug_annotation.proto

// Proto representation of untyped key/value annotations provided in TRACE_EVENT
// macros. Users of the Perfetto SDK should prefer to use the
// perfetto::TracedValue API to fill these protos, rather than filling them
// manually.
//
// Debug annotations are intended for debug use and are not considered a stable
// API of the trace contents. Trace-based metrics that use debug annotation
// values are prone to breakage, so please rely on typed TrackEvent fields for
// these instead.
//
// DebugAnnotations support nested arrays and dictionaries. Each entry is
// encoded as a single DebugAnnotation message. Only dictionary entries
// set the "name" field. The TrackEvent message forms an implicit root
// dictionary.
//
// Example TrackEvent with nested annotations:
//   track_event {
//     debug_annotations {
//       name: "foo"
//       dict_entries {
//         name: "a"
//         bool_value: true
//       }
//       dict_entries {
//         name: "b"
//         int_value: 123
//       }
//     }
//     debug_annotations {
//       name: "bar"
//       array_values {
//         string_value: "hello"
//       }
//       array_values {
//         string_value: "world"
//       }
//     }
//   }
//
// Next ID: 18.
// Reserved ID: 15
message DebugAnnotation {
  // Name fields are set only for dictionary entries.
  oneof name_field {
    // interned DebugAnnotationName.
    uint64 name_iid = 1;
    // non-interned variant.
    string name = 10;
  }

  oneof value {
    bool bool_value = 2;
    uint64 uint_value = 3;
    int64 int_value = 4;
    double double_value = 5;
    // Pointers are stored in a separate type as the JSON output treats them
    // differently from other uint64 values.
    uint64 pointer_value = 7;

    // Deprecated. Use dict_entries / array_values instead.
    NestedValue nested_value = 8;

    // Legacy instrumentation may not support conversion of nested data to
    // NestedValue yet.
    string legacy_json_value = 9;

    // interned and non-interned variants of strings.
    string string_value = 6;
    // Corresponds to |debug_annotation_string_values| field in InternedData.
    uint64 string_value_iid = 17;
  }

  // Used to embed arbitrary proto messages (which are also typically used to
  // represent typed TrackEvent arguments). |proto_type_name| or
  // |proto_type_name_iid| are storing the full name of the proto messages (e.g.
  // .perfetto.protos.DebugAnnotation) and |proto_value| contains the serialised
  // proto messages. See |TracedValue::WriteProto| for more details.
  oneof proto_type_descriptor {
    string proto_type_name = 16;
    // interned DebugAnnotationValueTypeName.
    uint64 proto_type_name_iid = 13;
  }
  optional bytes proto_value = 14;

  repeated DebugAnnotation dict_entries = 11;
  repeated DebugAnnotation array_values = 12;

  // Deprecated legacy way to use nested values. Only kept for
  // backwards-compatibility in TraceProcessor. May be removed in the future -
  // code filling protos should use |dict_entries| and |array_values| instead.
  message NestedValue {
    enum NestedType {
      // leaf value.
      UNSPECIFIED = 0;
      DICT = 1;
      ARRAY = 2;
    }
    optional NestedType nested_type = 1;

    repeated string dict_keys = 2;
    repeated NestedValue dict_values = 3;
    repeated NestedValue array_values = 4;
    optional int64 int_value = 5;
    optional double double_value = 6;
    optional bool bool_value = 7;
    optional string string_value = 8;
  }
}

// --------------------
// Interned data types:
// --------------------

message DebugAnnotationName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// See the |proto_type_descriptor| comment.
message DebugAnnotationValueTypeName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/debug_annotation.proto

// Begin of protos/perfetto/trace/track_event/log_message.proto

message LogMessage {
  // interned SourceLocation.
  optional uint64 source_location_iid = 1;
  // interned LogMessageBody.
  optional uint64 body_iid = 2;
  enum Priority {
    PRIO_UNSPECIFIED = 0;
    PRIO_UNUSED = 1;
    PRIO_VERBOSE = 2;
    PRIO_DEBUG = 3;
    PRIO_INFO = 4;
    PRIO_WARN = 5;
    PRIO_ERROR = 6;
    PRIO_FATAL = 7;
  }
  optional Priority prio = 3;
}

// --------------------
// Interned data types:
// --------------------

message LogMessageBody {
  optional uint64 iid = 1;
  optional string body = 2;
}

// End of protos/perfetto/trace/track_event/log_message.proto

// Begin of protos/perfetto/trace/track_event/source_location.proto

// --------------------
// Interned data types:
// --------------------

// A source location, represented as a native symbol.
// This is similar to `message Frame` from
// protos/perfetto/trace/profiling/profile_common.proto, but for abitrary
// source code locations (for example in track event args), not stack frames.
message UnsymbolizedSourceLocation {
  optional uint64 iid = 1;
  optional uint64 mapping_id = 2;
  optional uint64 rel_pc = 3;
}

message SourceLocation {
  optional uint64 iid = 1;
  optional string file_name = 2;
  optional string function_name = 3;
  optional uint32 line_number = 4;
}

// End of protos/perfetto/trace/track_event/source_location.proto

// Begin of protos/perfetto/trace/track_event/pixel_modem.proto

// Event insights emitted by the Pixel modem.
message PixelModemEventInsight {
  // Opaque string containing arguments from the modem.
  optional string detokenized_message = 1;
}

// End of protos/perfetto/trace/track_event/pixel_modem.proto

// Begin of protos/perfetto/trace/track_event/screenshot.proto

message Screenshot {
  optional bytes jpg_image = 1;
}

// End of protos/perfetto/trace/track_event/screenshot.proto

// Begin of protos/perfetto/trace/track_event/task_execution.proto

// TrackEvent arguments describing the execution of a task.
message TaskExecution {
  // Source location that the task was posted from.
  // interned SourceLocation.
  optional uint64 posted_from_iid = 1;
}
// End of protos/perfetto/trace/track_event/task_execution.proto

// Begin of protos/perfetto/trace/track_event/track_event.proto

// NOTE: Full TrackEvent support in the client lib and chrome is WIP, thus these
// protos are still subject to change. Don't depend on them staying as they are.

// Trace events emitted by client instrumentation library (TRACE_EVENT macros),
// which describe activity on a track, such as a thread or asynchronous event
// track. The track is specified using separate TrackDescriptor messages and
// referred to via the track's UUID.
//
// A simple TrackEvent packet specifies a timestamp, category, name and type:
// ```protobuf
//   trace_packet {
//     timestamp: 1000
//     track_event {
//       categories: ["my_cat"]
//       name: "my_event"
//       type: TYPE_INSTANT
//      }
//    }
// ```
//
// To associate an event with a custom track (e.g. a thread), the track is
// defined in a separate packet and referred to from the TrackEvent by its UUID:
// ```protobuf
//   trace_packet {
//     track_descriptor {
//       track_uuid: 1234
//       name: "my_track"
//
//       // Optionally, associate the track with a thread.
//       thread_descriptor {
//         pid: 10
//         tid: 10
//         ..
//       }
//     }
//   }
// ```
//
// A pair of TYPE_SLICE_BEGIN and _END events form a slice on the track:
//
// ```protobuf
//   trace_packet {
//     timestamp: 1200
//     track_event {
//       track_uuid: 1234
//       categories: ["my_cat"]
//       name: "my_slice"
//       type: TYPE_SLICE_BEGIN
//     }
//   }
//   trace_packet {
//     timestamp: 1400
//     track_event {
//       track_uuid: 1234
//       type: TYPE_SLICE_END
//     }
//   }
// ```
// TrackEvents also support optimizations to reduce data repetition and encoded
// data size, e.g. through data interning (names, categories, ...) and delta
// encoding of timestamps/counters. For details, see the InternedData message.
// Further, default values for attributes of events on the same sequence (e.g.
// their default track association) can be emitted as part of a
// TrackEventDefaults message.
//
// Next reserved id: 13 (up to 15). Next id: 52.
message TrackEvent {
  // Names of categories of the event. In the client library, categories are a
  // way to turn groups of individual events on or off.
  // interned EventCategoryName.
  repeated uint64 category_iids = 3;
  // non-interned variant.
  repeated string categories = 22;

  // Optional name of the event for its display in trace viewer. May be left
  // unspecified for events with typed arguments.
  //
  // Note that metrics should not rely on event names, as they are prone to
  // changing. Instead, they should use typed arguments to identify the events
  // they are interested in.
  oneof name_field {
    // interned EventName.
    uint64 name_iid = 10;
    // non-interned variant.
    string name = 23;
  }

  // TODO(eseckler): Support using binary symbols for category/event names.

  // Type of the TrackEvent (required if |phase| in LegacyEvent is not set).
  enum Type {
    TYPE_UNSPECIFIED = 0;

    // Slice events are events that have a begin and end timestamp, i.e. a
    // duration. They can be nested similar to a callstack: If, on the same
    // track, event B begins after event A, but before A ends, B is a child
    // event of A and will be drawn as a nested event underneath A in the UI.
    // Note that child events should always end before their parents (e.g. B
    // before A).
    //
    // Each slice event is formed by a pair of BEGIN + END events. The END event
    // does not need to repeat any TrackEvent fields it has in common with its
    // corresponding BEGIN event. Arguments and debug annotations of the BEGIN +
    // END pair will be merged during trace import.
    //
    // Note that we deliberately chose not to support COMPLETE events (which
    // would specify a duration directly) since clients would need to delay
    // writing them until the slice is completed, which can result in reordered
    // events in the trace and loss of unfinished events at the end of a trace.
    TYPE_SLICE_BEGIN = 1;
    TYPE_SLICE_END = 2;

    // Instant events are nestable events without duration. They can be children
    // of slice events on the same track.
    TYPE_INSTANT = 3;

    // Event that provides a value for a counter track. |track_uuid| should
    // refer to a counter track and |counter_value| set to the new value. Note
    // that most other TrackEvent fields (e.g. categories, name, ..) are not
    // supported for TYPE_COUNTER events. See also CounterDescriptor.
    TYPE_COUNTER = 4;
  }
  optional Type type = 9;

  // Identifies the track of the event. The default value may be overridden
  // using TrackEventDefaults, e.g., to specify the track of the TraceWriter's
  // sequence (in most cases sequence = one thread). If no value is specified
  // here or in TrackEventDefaults, the TrackEvent will be associated with an
  // implicit trace-global track (uuid 0). See TrackDescriptor::uuid.
  optional uint64 track_uuid = 11;

  // A new value for a counter track. |track_uuid| should refer to a track with
  // a CounterDescriptor, and |type| should be TYPE_COUNTER. For a more
  // efficient encoding of counter values that are sampled at the beginning/end
  // of a slice, see |extra_counter_values| and |extra_counter_track_uuids|.
  // Counter values can optionally be encoded in as delta values (positive or
  // negative) on each packet sequence (see CounterIncrementalBase).
  oneof counter_value_field {
    int64 counter_value = 30;
    double double_counter_value = 44;
  }

  // To encode counter values more efficiently, we support attaching additional
  // counter values to a TrackEvent of any type. All values will share the same
  // timestamp specified in the TracePacket. The value at
  // extra_counter_values[N] is for the counter track referenced by
  // extra_counter_track_uuids[N].
  //
  // |extra_counter_track_uuids| may also be set via TrackEventDefaults. There
  // should always be equal or more uuids than values. It is valid to set more
  // uuids (e.g. via defaults) than values. If uuids are specified in
  // TrackEventDefaults and a TrackEvent, the TrackEvent uuids override the
  // default uuid list.
  //
  // For example, this allows snapshotting the thread time clock at each
  // thread-track BEGIN and END event to capture the cpu time delta of a slice.
  repeated uint64 extra_counter_track_uuids = 31;
  repeated int64 extra_counter_values = 12;

  // Counter snapshots using floating point instead of integer values.
  repeated uint64 extra_double_counter_track_uuids = 45;
  repeated double extra_double_counter_values = 46;

  // IDs of flows originating, passing through, or ending at this event.
  // Flow IDs are global within a trace.
  //
  // A flow connects a sequence of TrackEvents within or across tracks, e.g.
  // an input event may be handled on one thread but cause another event on
  // a different thread - a flow between the two events can associate them.
  //
  // The direction of the flows between events is inferred from the events'
  // timestamps. The earliest event with the same flow ID becomes the source
  // of the flow. Any events thereafter are intermediate steps of the flow,
  // until the flow terminates at the last event with the flow ID.
  //
  // Flows can also be explicitly terminated (see |terminating_flow_ids|), so
  // that the same ID can later be reused for another flow.
  // DEPRECATED. Only kept for backwards compatibility. Use |flow_ids|.
  repeated uint64 flow_ids_old = 36 [deprecated = true];
  // TODO(b/204341740): replace "flow_ids_old" with "flow_ids" to reduce memory
  // consumption.
  repeated fixed64 flow_ids = 47;

  // List of flow ids which should terminate on this event, otherwise same as
  // |flow_ids|.
  // Any one flow ID should be either listed as part of |flow_ids| OR
  // |terminating_flow_ids|, not both.
  // DEPRECATED. Only kept for backwards compatibility.  Use
  // |terminating_flow_ids|.
  repeated uint64 terminating_flow_ids_old = 42 [deprecated = true];
  // TODO(b/204341740): replace "terminating_flow_ids_old" with
  // "terminating_flow_ids" to reduce memory consumption.
  repeated fixed64 terminating_flow_ids = 48;

  // ---------------------------------------------------------------------------
  // TrackEvent arguments:
  // ---------------------------------------------------------------------------

  // Unstable key/value annotations shown in the trace viewer but not intended
  // for metrics use.
  repeated DebugAnnotation debug_annotations = 4;

  // Typed event arguments:
  optional TaskExecution task_execution = 5;
  optional LogMessage log_message = 21;
  optional Screenshot screenshot = 50;
  optional PixelModemEventInsight pixel_modem_event_insight = 51;

  // This field is used only if the source location represents the function that
  // executes during this event.
  oneof source_location_field {
    // Non-interned field.
    SourceLocation source_location = 33;
    // Interned field.
    uint64 source_location_iid = 34;
  }

  // New argument types go here :)

  // Extension range for typed events defined externally.
  // See docs/design-docs/extensions.md for more details.
  //
  // Extension support is work-in-progress, in the future the way to reserve a
  // subrange for a particular project will be described here and in the design
  // document linked above.
  //
  // Contact perfetto-dev@googlegroups.com if you are interested in a subrange
  // for your project.

  // Extension range reserved for chromium:
  // https://source.chromium.org/chromium/chromium/src/+/main:base/tracing/protos/chrome_track_event.proto
  extensions 1000 to 1999;
  // Extension range reserved for https://b.corp.google.com/issues/301227627.
  extensions 2000 to 2000;
  // Extension range reserved for android:
  // protos/perfetto/trace/android/android_track_event.proto
  extensions 2001 to 2999;
  // Extension range for future use.
  extensions 3000 to 9899;
  // Reserved for Perfetto unit and integration tests.
  extensions 9900 to 10000;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy event fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // Deprecated. Use the |timestamp| and |timestamp_clock_id| fields in
  // TracePacket instead.
  //
  // Timestamp in microseconds (usually CLOCK_MONOTONIC).
  oneof timestamp {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 timestamp_delta_us = 1;
    // Absolute value (e.g. a manually specified timestamp in the macro).
    // This is a one-off value that does not affect delta timestamp computation
    // in subsequent TrackEvents.
    int64 timestamp_absolute_us = 16;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread time instead.
  //
  // CPU time for the current thread (e.g., CLOCK_THREAD_CPUTIME_ID) in
  // microseconds.
  oneof thread_time {
    // Delta timestamp value since the last TrackEvent or ThreadDescriptor. To
    // calculate the absolute timestamp value, sum up all delta values of the
    // preceding TrackEvents since the last ThreadDescriptor and add the sum to
    // the |reference_timestamp| in ThreadDescriptor. This value should always
    // be positive.
    int64 thread_time_delta_us = 2;
    // This is a one-off absolute value that does not affect delta timestamp
    // computation in subsequent TrackEvents.
    int64 thread_time_absolute_us = 17;
  }

  // Deprecated. Use |extra_counter_values| and |extra_counter_track_uuids| to
  // encode thread instruction count instead.
  //
  // Value of the instruction counter for the current thread.
  oneof thread_instruction_count {
    // Same encoding as |thread_time| field above.
    int64 thread_instruction_count_delta = 8;
    int64 thread_instruction_count_absolute = 20;
  }
}

// Default values for fields of all TrackEvents on the same packet sequence.
// Should be emitted as part of TracePacketDefaults whenever incremental state
// is cleared. It's defined here because field IDs should match those of the
// corresponding fields in TrackEvent.
message TrackEventDefaults {
  optional uint64 track_uuid = 11;
  repeated uint64 extra_counter_track_uuids = 31;
  repeated uint64 extra_double_counter_track_uuids = 45;

  // TODO(eseckler): Support default values for more TrackEvent fields.
}

// --------------------
// Interned data types:
// --------------------

message EventCategory {
  optional uint64 iid = 1;
  optional string name = 2;
}

message EventName {
  optional uint64 iid = 1;
  optional string name = 2;
}

// End of protos/perfetto/trace/track_event/track_event.proto

// Begin of protos/perfetto/trace/interned_data/interned_data.proto

// ------------------------------ DATA INTERNING: ------------------------------
// Interning indexes are built up gradually by adding the entries contained in
// each TracePacket of the same packet sequence (packets emitted by the same
// producer and TraceWriter, see |trusted_packet_sequence_id|). Thus, packets
// can only refer to interned data from other packets in the same sequence.
//
// The writer will emit new entries when it encounters new internable values
// that aren't yet in the index. Data in current and subsequent TracePackets can
// then refer to the entry by its position (interning ID, abbreviated "iid") in
// its index. An interning ID with value 0 is considered invalid (not set).
//
// Because of the incremental build-up, the interning index will miss data when
// TracePackets are lost, e.g. because a chunk was overridden in the central
// ring buffer. To avoid invalidation of the whole trace in such a case, the
// index is periodically reset (see SEQ_INCREMENTAL_STATE_CLEARED).
// When packet loss occurs, the reader will only lose interning data up to the
// next reset.
// -----------------------------------------------------------------------------

// Message that contains new entries for the interning indices of a packet
// sequence.
//
// The writer will usually emit new entries in the same TracePacket that first
// refers to them (since the last reset of interning state). They may also be
// emitted proactively in advance of referring to them in later packets.
//
// Next reserved id: 8 (up to 15).
// Next id: 42.
message InternedData {
  // TODO(eseckler): Replace iid fields inside interned messages with
  // map<iid, message> type fields in InternedData.

  // Each field's message type needs to specify an |iid| field, which is the ID
  // of the entry in the field's interning index. Each field constructs its own
  // index, thus interning IDs are scoped to the tracing session and field
  // (usually as a counter for efficient var-int encoding), and optionally to
  // the incremental state generation of the packet sequence.
  repeated EventCategory event_categories = 1;
  repeated EventName event_names = 2;
  repeated DebugAnnotationName debug_annotation_names = 3;
  repeated DebugAnnotationValueTypeName debug_annotation_value_type_names = 27;
  repeated SourceLocation source_locations = 4;
  repeated UnsymbolizedSourceLocation unsymbolized_source_locations = 28;
  repeated LogMessageBody log_message_body = 20;
  repeated HistogramName histogram_names = 25;

  // Note: field IDs up to 15 should be used for frequent data only.

  // Build IDs of exectuable files.
  repeated InternedString build_ids = 16;
  // Paths to executable files.
  repeated InternedString mapping_paths = 17;
  // Paths to source files.
  repeated InternedString source_paths = 18;
  // Names of functions used in frames below.
  repeated InternedString function_names = 5;
  // Symbols that were added to this trace after the fact.
  repeated ProfiledFrameSymbols profiled_frame_symbols = 21;

  // Executable files mapped into processes.
  repeated Mapping mappings = 19;
  // Frames of callstacks of a program.
  repeated Frame frames = 6;
  // A callstack of a program.
  repeated Callstack callstacks = 7;

  // Additional Vulkan information sent in a VulkanMemoryEvent message
  repeated InternedString vulkan_memory_keys = 22;

  // This is set when FtraceConfig.symbolize_ksyms = true.
  // The id of each symbol the number that will be reported in ftrace events
  // like sched_block_reason.caller and is obtained from a monotonic counter.
  // The same symbol can have different indexes in different bundles.
  // This is is NOT the real address. This is to avoid disclosing KASLR through
  // traces.
  repeated InternedString kernel_symbols = 26;

  // Interned string values in the DebugAnnotation proto.
  repeated InternedString debug_annotation_string_values = 29;

  // Interned protolog strings args.
  repeated InternedString protolog_string_args = 36;
  // Interned protolog stacktraces.
  repeated InternedString protolog_stacktrace = 37;

  // viewcapture
  repeated InternedString viewcapture_package_name = 38;
  repeated InternedString viewcapture_window_name = 39;
  repeated InternedString viewcapture_view_id = 40;
  repeated InternedString viewcapture_class_name = 41;
}

// End of protos/perfetto/trace/interned_data/interned_data.proto

// Begin of protos/perfetto/trace/profiling/profile_packet.proto

// This file contains a mixture of messages emitted by various sampling
// profilers:
//
// Memory allocator profiling
// ----------------
// ProfilePacket:
//   The packet emitted by heapprofd, which started off as a native heap
//   (malloc/free) profiler, but now supports custom allocators as well. Each
//   packet contains a preaggregated state of the heap at snapshot time, which
//   report the total allocated/free bytes per callstack (plus other info such
//   as the number of samples).
// StreamingAllocation/StreamingFree:
//   Emitted by heapprofd when configured in streaming mode (i.e. when
//   stream_allocations = true). This is only for local testing, and doesn't
//   report callstacks (only address time and size of each alloc/free). It can
//   lead to enormous traces, as it contains the stream of each alloc/free call.
//
// Callstack sampling
// ------------------
// StreamingProfilePacket:
//   The packet emitted by the chromium in-process sampling profiler, which is
//   based on periodically sending a signal to itself, and unwinding the stack
//   in the signal handler. Each packet contains a series of individual stack
//   samples for a Chromium thread.
//
// Callstack and performance counter sampling
// ---------------------
// PerfSample:
//   The packet emitted by traced_perf sampling performance profiler based on
//   the perf_event_open syscall. Each packet represents an individual sample
//   of a performance counter (which might be a timer), and optionally a
//   callstack of the process that was scheduled at the time of the sample.
//

// The packet emitted by heapprofd for each heap snapshot. A snapshot can
// involve more than one ProfilePacket if the snapshot is big (when |continued|
// is true). The cardinality and grouping is as follows:
// A ProfilePacket contains:
//  - 1+ per-process heap snapshots (ProcessHeapSamples). Normally there is only
//    one heap per process (the main malloc/free heap), but there can be more if
//    the process is using the heapprofd API to profile custom allocators.
//  - Globally interned strings, mappings and frames (to allow de-duplicating
//    frames/mapping in common between different processes).
// A ProcessHeapSamples contains:
//  - The process and heap identifier.
//  - A number of HeapSample, one for each callsite that had some alloc/frees.
//  - Statistics about heapprofd internals (e.g., sampling/unwinding timings).
// A HeapSample contains statistics about callsites:
//  - Total number of bytes allocated and freed from that callsite.
//  - Total number of alloc/free calls sampled.
//  - Stats at the local maximum when dump_at_max = true.
// See https://perfetto.dev/docs/data-sources/native-heap-profiler for more.
message ProfilePacket {
  // The following interning tables are only used in Android version Q.
  // In newer versions, these tables are in InternedData
  // (see protos/perfetto/trace/interned_data) and are shared across
  // multiple ProfilePackets.
  // For backwards compatibility, consumers need to first look up interned
  // data in the tables within the ProfilePacket, and then, if they are empty,
  // look up in the InternedData instead.
  repeated InternedString strings = 1;
  repeated Mapping mappings = 4;
  repeated Frame frames = 2;
  repeated Callstack callstacks = 3;

  message Histogram {
    message Bucket {
      // This bucket counts values from the previous bucket's (or -infinity if
      // this is the first bucket) upper_limit (inclusive) to this upper_limit
      // (exclusive).
      optional uint64 upper_limit = 1;
      // This is the highest bucket. This is set instead of the upper_limit. Any
      // values larger or equal to the previous bucket's upper_limit are counted
      // in this bucket.
      optional bool max_bucket = 2;
      // Number of values that fall into this range.
      optional uint64 count = 3;
    }
    repeated Bucket buckets = 1;
  }

  message ProcessStats {
    optional uint64 unwinding_errors = 1;
    optional uint64 heap_samples = 2;
    optional uint64 map_reparses = 3;
    optional Histogram unwinding_time_us = 4;
    optional uint64 total_unwinding_time_us = 5;
    optional uint64 client_spinlock_blocked_us = 6;
  }

  // If this is true, the next ProfilePacket in this package_sequence_id is a
  // continuation of this one.
  // To get all samples for a process, accummulate its
  // ProcessHeapSamples.samples until you see continued=false.
  optional bool continued = 6;

  // Index of this ProfilePacket on its package_sequence_id. Can be used
  // to detect dropped data.
  // Verify these are consecutive.
  optional uint64 index = 7;
}

// Namespace for the contained enums.
message Profiling {
  enum CpuMode {
    MODE_UNKNOWN = 0;
    MODE_KERNEL = 1;
    MODE_USER = 2;
    // The following values aren't expected, but included for completeness:
    MODE_HYPERVISOR = 3;
    MODE_GUEST_KERNEL = 4;
    MODE_GUEST_USER = 5;
  }

  // Enumeration of libunwindstack's error codes.
  // NB: the integral representations of the two enums are different.
  enum StackUnwindError {
    UNWIND_ERROR_UNKNOWN = 0;
    UNWIND_ERROR_NONE = 1;
    UNWIND_ERROR_MEMORY_INVALID = 2;
    UNWIND_ERROR_UNWIND_INFO = 3;
    UNWIND_ERROR_UNSUPPORTED = 4;
    UNWIND_ERROR_INVALID_MAP = 5;
    UNWIND_ERROR_MAX_FRAMES_EXCEEDED = 6;
    UNWIND_ERROR_REPEATED_FRAME = 7;
    UNWIND_ERROR_INVALID_ELF = 8;
    UNWIND_ERROR_SYSTEM_CALL = 9;
    UNWIND_ERROR_THREAD_TIMEOUT = 10;
    UNWIND_ERROR_THREAD_DOES_NOT_EXIST = 11;
    UNWIND_ERROR_BAD_ARCH = 12;
    UNWIND_ERROR_MAPS_PARSE = 13;
    UNWIND_ERROR_INVALID_PARAMETER = 14;
    UNWIND_ERROR_PTRACE_CALL = 15;
  }
}

// Packet emitted by the traced_perf sampling performance profiler, which
// gathers data via the perf_event_open syscall. Each packet contains an
// individual sample with a counter value, and optionally a
// callstack.
//
// Timestamps are within the root packet. The config can specify the clock, or
// the implementation will default to CLOCK_MONOTONIC_RAW. Within the Android R
// timeframe, the default was CLOCK_BOOTTIME.
//
// There are several distinct views of this message:
// * indication of kernel buffer data loss (kernel_records_lost set)
// * indication of skipped samples (sample_skipped_reason set)
// * notable event in the sampling implementation (producer_event set)
// * normal sample (timebase_count set, typically also callstack_iid)
message PerfSample {
  optional uint32 cpu = 1;
  optional uint32 pid = 2;
  optional uint32 tid = 3;

  // Execution state that the process was sampled at.
  optional Profiling.CpuMode cpu_mode = 5;

  // Value of the timebase counter (since the event was configured, no deltas).
  optional uint64 timebase_count = 6;

  // Unwound callstack. Might be partial, in which case a synthetic "error"
  // frame is appended, and |unwind_error| is set accordingly.
  optional uint64 callstack_iid = 4;

  // If set, stack unwinding was incomplete due to an error.
  // Unset values should be treated as UNWIND_ERROR_NONE.
  oneof optional_unwind_error { Profiling.StackUnwindError unwind_error = 16; };

  // If set, indicates that this message is not a sample, but rather an
  // indication of data loss in the ring buffer allocated for |cpu|. Such data
  // loss occurs when the kernel has insufficient ring buffer capacity to write
  // a record (which gets discarded). A record in this context is an individual
  // ring buffer entry, and counts more than just sample records.
  //
  // The |timestamp| of the packet corresponds to the time that the producer
  // wrote the packet for trace-sorting purposes alone, and should not be
  // interpreted relative to the sample timestamps. This field is sufficient to
  // detect that *some* kernel data loss happened within the trace, but not the
  // specific time bounds of that loss (which would require tracking precedessor
  // & successor timestamps, which is not deemed necessary at the moment).
  optional uint64 kernel_records_lost = 17;

  // If set, indicates that the profiler encountered a sample that was relevant,
  // but was skipped.
  enum SampleSkipReason {
    PROFILER_SKIP_UNKNOWN = 0;
    PROFILER_SKIP_READ_STAGE = 1;
    PROFILER_SKIP_UNWIND_STAGE = 2;
    PROFILER_SKIP_UNWIND_ENQUEUE = 3;
  }
  oneof optional_sample_skipped_reason {
    SampleSkipReason sample_skipped_reason = 18;
  };

  // A notable event within the sampling implementation.
  message ProducerEvent {
    enum DataSourceStopReason {
      PROFILER_STOP_UNKNOWN = 0;
      PROFILER_STOP_GUARDRAIL = 1;
    }
    oneof optional_source_stop_reason {
      DataSourceStopReason source_stop_reason = 1;
    }
  }
  optional ProducerEvent producer_event = 19;
}

// Submessage for TracePacketDefaults.
message PerfSampleDefaults {
  // The sampling timebase. Might not be identical to the data source config if
  // the implementation decided to default/override some parameters.
  optional PerfEvents.Timebase timebase = 1;

  // If the config requested process sharding, report back the count and which
  // of those bins was selected. Never changes for the duration of a trace.
  optional uint32 process_shard_count = 2;
  optional uint32 chosen_process_shard = 3;
}

// End of protos/perfetto/trace/profiling/profile_packet.proto

// Begin of protos/perfetto/trace/ps/process_stats.proto

// Per-process periodically sampled stats. These samples are wrapped in a
// dedicated message (as opposite to be fields in process_tree.proto) because
// they are dumped at a different rate than cmdline and thread list.
// Note: not all of these stats will be present in every ProcessStats message
// and sometimes processes may be missing. This is because counters are
// cached to reduce emission of counters which do not change.
message ProcessStats {
  // Per-thread periodically sampled stats.
  // Note: not all of these stats will be present in every message. See the note
  // for ProcessStats.
  message Thread {
    optional int32 tid = 1;

    // DEPRECATED cpu_freq_indices
    reserved 2;

    // DEPRECATED cpu_freq_ticks
    reserved 3;

    // DEPRECATED cpu_freq_full
    reserved 4;
  }

  message FDInfo {
    optional uint64 fd = 1;
    optional string path = 2;
  }

  message Process {
    optional int32 pid = 1;

    repeated Thread threads = 11;

    // See /proc/[pid]/status in `man 5 proc` for a description of these fields.
    optional uint64 vm_size_kb = 2;
    optional uint64 vm_rss_kb = 3;
    optional uint64 rss_anon_kb = 4;
    optional uint64 rss_file_kb = 5;
    optional uint64 rss_shmem_kb = 6;
    optional uint64 vm_swap_kb = 7;
    optional uint64 vm_locked_kb = 8;
    optional uint64 vm_hwm_kb = 9;
    // When adding a new field remember to update kProcMemCounterSize in
    // the trace processor.

    optional int64 oom_score_adj = 10;

    // The peak resident set size is resettable in newer Posix kernels.
    // This field specifies if reset is supported and if the writer had reset
    // the peaks after each process stats recording.
    optional bool is_peak_rss_resettable = 12;

    // Private, shared and swap footprint of the process as measured by
    // Chrome. To know more about these metrics refer to:
    // https://docs.google.com/document/d/1_WmgE1F5WUrhwkPqJis3dWyOiUmQKvpXp5cd4w86TvA
    optional uint32 chrome_private_footprint_kb = 13;
    optional uint32 chrome_peak_resident_set_kb = 14;

    repeated FDInfo fds = 15;

    // These fields are set only when scan_smaps_rollup=true
    optional uint64 smr_rss_kb = 16;
    optional uint64 smr_pss_kb = 17;
    optional uint64 smr_pss_anon_kb = 18;
    optional uint64 smr_pss_file_kb = 19;
    optional uint64 smr_pss_shmem_kb = 20;
    optional uint64 smr_swap_pss_kb = 23;

    // Time spent scheduled in user mode in nanoseconds. Parsed from utime in
    // /proc/pid/stat. Recorded if record_process_runtime config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 runtime_user_mode = 21;

    // Time spent scheduled in kernel mode in nanoseconds. Parsed from stime in
    // /proc/pid/stat. Recorded if record_process_runtime config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 runtime_kernel_mode = 22;
  }
  repeated Process processes = 1;

  // The time at which we finish collecting this batch of samples;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 2;
}

// End of protos/perfetto/trace/ps/process_stats.proto

// Begin of protos/perfetto/trace/ps/process_tree.proto

// Metadata about the processes and threads in the trace.
// Note: this proto was designed to be filled in by traced_probes and should
// only be populated with accurate information coming from the system. Other
// trace writers should prefer to fill ThreadDescriptor and ProcessDescriptor
// in TrackDescriptor.
message ProcessTree {
  // Representation of a thread.
  message Thread {
    // The thread ID (as per gettid()) in the root PID namespace.
    optional int32 tid = 1;

    // Thread group id (i.e. the PID of the process, == TID of the main thread)
    optional int32 tgid = 3;

    // The name of the thread.
    optional string name = 2;

    // The non-root-level thread IDs if the thread runs in a PID namespace. Read
    // from the NSpid entry of /proc/<tid>/status, with the first element (root-
    // level thread ID) omitted.
    repeated int32 nstid = 4;
  }

  // Representation of a process.
  message Process {
    // The UNIX process ID, aka thread group ID (as per getpid()) in the root
    // PID namespace.
    optional int32 pid = 1;

    // The parent process ID, as per getppid().
    optional int32 ppid = 2;

    // The command line for the process, as per /proc/pid/cmdline.
    // If it is a kernel thread there will only be one cmdline field
    // and it will contain /proc/pid/comm.
    repeated string cmdline = 3;

    // The uid for the process, as per /proc/pid/status.
    optional int32 uid = 5;

    // The non-root-level process IDs if the process runs in a PID namespace.
    // Read from the NSpid entry of /proc/<pid>/status, with the first element
    // (root-level process ID) omitted.
    repeated int32 nspid = 6;

    // Timestamp of when the process was created, in nanoseconds
    // from boot. Parsed from starttime in /proc/pid/stat.
    // Recorded if record_process_age config option is set.
    // Resolution of "clock ticks", usually 10ms.
    optional uint64 process_start_from_boot = 7;

    // threads_deprecated
    reserved 4;
  }

  // List of processes and threads in the client. These lists are incremental
  // and not exhaustive. A process and its threads might show up separately in
  // different ProcessTree messages. A thread might event not show up at all, if
  // no sched_switch activity was detected, for instance:
  // #0 { processes: [{pid: 10, ...}], threads: [{pid: 11, tgid: 10}] }
  // #1 { threads: [{pid: 12, tgid: 10}] }
  // #2 { processes: [{pid: 20, ...}], threads: [{pid: 13, tgid: 10}] }
  repeated Process processes = 1;
  repeated Thread threads = 2;

  // The time at which we finish collecting this process tree;
  // the top-level packet timestamp is the time at which
  // we begin collection.
  optional uint64 collection_end_timestamp = 3;
}

// End of protos/perfetto/trace/ps/process_tree.proto

// Begin of protos/perfetto/trace/remote_clock_sync.proto

// Records the parameters for aligning clock readings between machines.
message RemoteClockSync {
  // Synchronized clock snapshots taken on both sides of the relay port (the
  // tracing service and the relay service). A round of clock synchronization
  // IPC takes emits 2 SyncedClocks messages, i.e., client snapshot -> host
  // snapshot -> client snapshot -> host snapshot.
  message SyncedClocks {
    optional ClockSnapshot client_clocks = 2;
    optional ClockSnapshot host_clocks = 3;
  }

  repeated SyncedClocks synced_clocks = 1;
}

// End of protos/perfetto/trace/remote_clock_sync.proto

// Begin of protos/perfetto/trace/trace_packet_defaults.proto

// Default values for TracePacket fields that hold for a particular TraceWriter
// packet sequence. This message contains a subset of the TracePacket fields
// with matching IDs. When provided, these fields define the default values
// that should be applied, at import time, to all TracePacket(s) with the same
// |trusted_packet_sequence_id|, unless otherwise specified in each packet.
//
// Should be reemitted whenever incremental state is cleared on the sequence.
message TracePacketDefaults {
  optional uint32 timestamp_clock_id = 58;

  // Default values for TrackEvents (e.g. default track).
  optional TrackEventDefaults track_event_defaults = 11;

  // Defaults for perf profiler packets (PerfSample).
  optional PerfSampleDefaults perf_sample_defaults = 12;
}
// End of protos/perfetto/trace/trace_packet_defaults.proto

// Begin of protos/perfetto/trace/trace_uuid.proto

// A random unique ID that identifies the trace.
// This message has been introduced in v32. Prior to that, the UUID was
// only (optionally) present in the TraceConfig.trace_uuid_msb/lsb fields.
// This has been moved to a standalone packet to deal with new use-cases for
// go/gapless-aot, where the same tracing session can be serialized several
// times, in which case the UUID is changed on each snapshot and does not match
// the one in the TraceConfig.
message TraceUuid {
  optional int64 msb = 1;
  optional int64 lsb = 2;
}

// End of protos/perfetto/trace/trace_uuid.proto

// Begin of protos/perfetto/trace/track_event/process_descriptor.proto

// Describes a process's attributes. Emitted as part of a TrackDescriptor,
// usually by the process's main thread.
//
// Next id: 9.
message ProcessDescriptor {
  optional int32 pid = 1;
  repeated string cmdline = 2;
  optional string process_name = 6;

  optional int32 process_priority = 5;
  // Process start time in nanoseconds.
  // The timestamp refers to the trace clock by default. Other clock IDs
  // provided in TracePacket are not supported.
  optional int64 start_timestamp_ns = 7;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // To support old UI. New UI should determine default sorting by process_type.
  optional int32 legacy_sort_index = 3;

  // Labels can be used to further describe properties of the work performed by
  // the process. For example, these can be used by Chrome renderer process to
  // provide titles of frames being rendered.
  repeated string process_labels = 8;
}

// End of protos/perfetto/trace/track_event/process_descriptor.proto

// Begin of protos/perfetto/trace/track_event/range_of_interest.proto

// This message specifies the "range of interest" for track events. With the
// `drop_track_event_data_before` option set to `kTrackEventRangeOfInterest`,
// Trace Processor drops track events outside of this range.
message TrackEventRangeOfInterest {
  optional int64 start_us = 1;
}
// End of protos/perfetto/trace/track_event/range_of_interest.proto

// Begin of protos/perfetto/trace/track_event/thread_descriptor.proto

// Describes a thread's attributes. Emitted as part of a TrackDescriptor,
// usually by the thread's trace writer.
//
// Next id: 9.
message ThreadDescriptor {
  optional int32 pid = 1;
  optional int32 tid = 2;

  optional string thread_name = 5;

  // ---------------------------------------------------------------------------
  // Deprecated / legacy fields, which will be removed in the future:
  // ---------------------------------------------------------------------------

  // Deprecated. Use ClockSnapshot in combination with TracePacket's timestamp
  // and timestamp_clock_id fields instead.
  optional int64 reference_timestamp_us = 6;

  // Absolute reference values. Clock values in subsequent TrackEvents can be
  // encoded accumulatively and relative to these. This reduces their var-int
  // encoding size.
  // TODO(eseckler): Deprecated. Replace these with ClockSnapshot encoding.
  optional int64 reference_thread_time_us = 7;
  optional int64 reference_thread_instruction_count = 8;

  // To support old UI. New UI should determine default sorting by thread_type.
  optional int32 legacy_sort_index = 3;
}

// End of protos/perfetto/trace/track_event/thread_descriptor.proto

// Begin of protos/perfetto/trace/track_event/counter_descriptor.proto

// Defines properties of a counter track, e.g. for built-in counters (thread
// time, instruction count, ..) or user-specified counters (e.g. memory usage of
// a specific app component).
//
// Counter tracks only support TYPE_COUNTER track events, which specify new
// values for the counter. For counters that require per-slice values, counter
// values can instead be provided in a more efficient encoding via TrackEvent's
// |extra_counter_track_uuids| and |extra_counter_values| fields. However,
// slice-type events cannot be emitted onto a counter track.
//
// Values for counters that are only emitted on a single packet sequence can
// optionally be delta-encoded, see |is_incremental|.
//
// Next id: 7.
message CounterDescriptor {
  // Built-in counters, usually with special meaning in the client library,
  // trace processor, legacy JSON format, or UI. Trace processor will infer a
  // track name from the enum value if none is provided in TrackDescriptor.
  enum BuiltinCounterType {
    COUNTER_UNSPECIFIED = 0;

    // Thread-scoped counters. The thread's track should be specified via
    // |parent_uuid| in the TrackDescriptor for such a counter.

    // implies UNIT_TIME_NS.
    COUNTER_THREAD_TIME_NS = 1;

    // implies UNIT_COUNT.
    COUNTER_THREAD_INSTRUCTION_COUNT = 2;
  }

  // Type of the values for the counters - to supply lower granularity units,
  // see also |unit_multiplier|.
  enum Unit {
    UNIT_UNSPECIFIED = 0;
    UNIT_TIME_NS = 1;
    UNIT_COUNT = 2;
    UNIT_SIZE_BYTES = 3;
    // TODO(eseckler): Support more units as necessary.
  }

  // For built-in counters (e.g. thread time). Custom user-specified counters
  // (e.g. those emitted by TRACE_COUNTER macros of the client library)
  // shouldn't set this, and instead provide a counter name via TrackDescriptor.
  optional BuiltinCounterType type = 1;

  // Names of categories of the counter (usually for user-specified counters).
  // In the client library, categories are a way to turn groups of individual
  // counters (or events) on or off.
  repeated string categories = 2;

  // Type of the counter's values. Built-in counters imply a value for this
  // field.
  optional Unit unit = 3;

  // In order to use a unit not defined as a part of |Unit|, a free-form unit
  // name can be used instead.
  optional string unit_name = 6;

  // Multiplication factor of this counter's values, e.g. to supply
  // COUNTER_THREAD_TIME_NS timestamps in microseconds instead.
  optional int64 unit_multiplier = 4;

  // Whether values for this counter are provided as delta values. Only
  // supported for counters that are emitted on a single packet-sequence (e.g.
  // thread time). Counter values in subsequent packets on the current packet
  // sequence will be interpreted as delta values from the sequence's most
  // recent value for the counter. When incremental state is cleared, the
  // counter value is considered to be reset to 0. Thus, the first value after
  // incremental state is cleared is effectively an absolute value.
  optional bool is_incremental = 5;

  // TODO(eseckler): Support arguments describing the counter (?).
  // repeated DebugAnnotation debug_annotations;
}

// End of protos/perfetto/trace/track_event/counter_descriptor.proto

// Begin of protos/perfetto/trace/track_event/track_descriptor.proto

// Defines a track for TrackEvents. Slices and instant events on the same track
// will be nested based on their timestamps, see TrackEvent::Type.
//
// A TrackDescriptor only needs to be emitted by one trace writer / producer and
// is valid for the entirety of the trace. To ensure the descriptor isn't lost
// when the ring buffer wraps, it should be reemitted whenever incremental state
// is cleared.
//
// As a fallback, TrackEvents emitted without an explicit track association will
// be associated with an implicit trace-global track (uuid = 0), see also
// |TrackEvent::track_uuid|. It is possible but not necessary to emit a
// TrackDescriptor for this implicit track.
//
// Next id: 11.
message TrackDescriptor {
  // Unique ID that identifies this track. This ID is global to the whole trace.
  // Producers should ensure that it is unlikely to clash with IDs emitted by
  // other producers. A value of 0 denotes the implicit trace-global track.
  //
  // For example, legacy TRACE_EVENT macros may use a hash involving the async
  // event id + id_scope, pid, and/or tid to compute this ID.
  optional uint64 uuid = 1;

  // A parent track reference can be used to describe relationships between
  // tracks. For example, to define an asynchronous track which is scoped to a
  // specific process, specify the uuid for that process's process track here.
  // Similarly, to associate a COUNTER_THREAD_TIME_NS counter track with a
  // thread, specify the uuid for that thread's thread track here.
  optional uint64 parent_uuid = 5;

  // Name of the track. Optional - if unspecified, it may be derived from the
  // process/thread name (process/thread tracks), the first event's name (async
  // tracks), or counter name (counter tracks).
  oneof static_or_dynamic_name {
    string name = 2;
    // This field is only set by the SDK when perfetto::StaticString is
    // provided.
    string static_name = 10;
  }

  // Associate the track with a process, making it the process-global track.
  // There should only be one such track per process (usually for instant
  // events; trace processor uses this fact to detect pid reuse). If you need
  // more (e.g. for asynchronous events), create child tracks using parent_uuid.
  //
  // Trace processor will merge events on a process track with slice-type events
  // from other sources (e.g. ftrace) for the same process into a single
  // timeline view.
  optional ProcessDescriptor process = 3;

  // Associate the track with a thread, indicating that the track's events
  // describe synchronous code execution on the thread. There should only be one
  // such track per thread (trace processor uses this fact to detect tid reuse).
  //
  // Trace processor will merge events on a thread track with slice-type events
  // from other sources (e.g. ftrace) for the same thread into a single timeline
  // view.
  optional ThreadDescriptor thread = 4;

  // Descriptor for a counter track. If set, the track will only support
  // TYPE_COUNTER TrackEvents (and values provided via TrackEvent's
  // |extra_counter_values|).
  optional CounterDescriptor counter = 8;

  // If true, forces Trace Processor to use separate tracks for track events
  // and system events for the same thread.
  // Track events timestamps in Chrome have microsecond resolution, while
  // system events use nanoseconds. It results in broken event nesting when
  // track events and system events share a track.
  optional bool disallow_merging_with_system_tracks = 9;
}

// End of protos/perfetto/trace/track_event/track_descriptor.proto

// Begin of protos/perfetto/trace/translation/translation_table.proto

// Translation rules for the trace processor.
// See the comments for each rule type for specific meaning.
message TranslationTable {
  oneof table {
    SliceNameTranslationTable slice_name = 4;
    ProcessTrackNameTranslationTable process_track_name = 5;
  }
}

// Raw -> deobfuscated slice name translation rules.
message SliceNameTranslationTable {
  map<string, string> raw_to_deobfuscated_name = 1;
};

// Raw -> deobfuscated process track name translation rules.
message ProcessTrackNameTranslationTable {
  map<string, string> raw_to_deobfuscated_name = 1;
};

// End of protos/perfetto/trace/translation/translation_table.proto

// Begin of protos/perfetto/trace/trigger.proto

// When a TracingSession receives a trigger it records the boot time nanoseconds
// in the TracePacket's timestamp field as well as the name of the producer that
// triggered it. We emit this data so filtering can be done on triggers received
// in the trace.
message Trigger {
  // Name of the trigger which was received.
  optional string trigger_name = 1;
  // The actual producer that activated |trigger|.
  optional string producer_name = 2;
  // The verified UID of the producer.
  optional int32 trusted_producer_uid = 3;
}

// End of protos/perfetto/trace/trigger.proto

// Begin of protos/perfetto/trace/ui_state.proto

// Common state for UIs visualizing Perfetto traces.
// This message can be appended as a TracePacket by UIs to save the
// visible state (e.g. scroll position/zoom state) for future opening
// of the trace.
// Design doc: go/trace-ui-state.
message UiState {
  // The start and end bounds of the viewport of the UI in nanoseconds.
  //
  // This is the absolute time associated to slices and other events in
  // trace processor tables (i.e. the |ts| column of most tables)
  optional int64 timeline_start_ts = 1;
  optional int64 timeline_end_ts = 2;

  // Indicates that the given process should be highlighted by the UI.
  message HighlightProcess {
    oneof selector {
      // The pid of the process to highlight. This is useful for UIs to focus
      // on tracks of a particular process in the trace.
      //
      // If more than one process in a trace has the same pid, it is UI
      // implementation specific how the process to be focused will be
      // chosen.
      uint32 pid = 1;

      // The command line of the process to highlight; for most Android apps,
      // this is the package name of the app. This is useful for UIs to focus
      // on a particular app in the trace.
      //
      // If more than one process hasthe same cmdline, it is UI implementation
      // specific how the process to be focused will be chosen.
      string cmdline = 2;
    }
  }
  optional HighlightProcess highlight_process = 3;
}
// End of protos/perfetto/trace/ui_state.proto

// Begin of protos/perfetto/trace/trace_packet.proto

// TracePacket is the root object of a Perfetto trace.
// A Perfetto trace is a linear sequence of TracePacket(s).
//
// The tracing service guarantees that all TracePacket(s) written by a given
// TraceWriter are seen in-order, without gaps or duplicates. If, for any
// reason, a TraceWriter sequence becomes invalid, no more packets are returned
// to the Consumer (or written into the trace file).
// TracePacket(s) written by different TraceWriter(s), hence even different
// data sources, can be seen in arbitrary order.
// The consumer can re-establish a total order, if interested, using the packet
// timestamps, after having synchronized the different clocks onto a global
// clock.
//
// The tracing service is agnostic of the content of TracePacket, with the
// exception of few fields (e.g.. trusted_*, trace_config) that are written by
// the service itself.
//
// See the [Buffers and Dataflow](/docs/concepts/buffers.md) doc for details.
//
// Next reserved id: 14 (up to 15).
// Next id: 113.
message TracePacket {
  // The timestamp of the TracePacket.
  // By default this timestamps refers to the trace clock (CLOCK_BOOTTIME on
  // Android). It can be overridden using a different timestamp_clock_id.
  // The clock domain definition in ClockSnapshot can also override:
  // - The unit (default: 1ns).
  // - The absolute vs delta encoding (default: absolute timestamp).
  optional uint64 timestamp = 8;

  // Specifies the ID of the clock used for the TracePacket |timestamp|. Can be
  // one of the built-in types from ClockSnapshot::BuiltinClocks, or a
  // producer-defined clock id.
  // If unspecified and if no default per-sequence value has been provided via
  // TracePacketDefaults, it defaults to BuiltinClocks::BOOTTIME.
  optional uint32 timestamp_clock_id = 58;

  oneof data {
    TrackEvent track_event = 11;

    // IDs up to 15 are reserved. They take only one byte to encode their
    // preamble so should be used for frequent events.

    TraceUuid trace_uuid = 89;
    PerfSample perf_sample = 66;

    // Only used by TrackEvent.
    TrackDescriptor track_descriptor = 60;
  }

  // AndroidInputEvent android_input_event (moved to winscope_extensions)
  reserved 106;

  // Trusted user id of the producer which generated this packet. Keep in sync
  // with TrustedPacket.trusted_uid.
  //
  // TODO(eseckler): Emit this field in a PacketSequenceDescriptor message
  // instead.
  oneof optional_trusted_uid {
    int32 trusted_uid = 3;
  };

  // Service-assigned identifier of the packet sequence this packet belongs to.
  // Uniquely identifies a producer + writer pair within the tracing session. A
  // value of zero denotes an invalid ID. Keep in sync with
  // TrustedPacket.trusted_packet_sequence_id.
  oneof optional_trusted_packet_sequence_id {
    uint32 trusted_packet_sequence_id = 10;
  }

  // Trusted process id of the producer which generated this packet, written by
  // the service.
  optional int32 trusted_pid = 79;

  // Incrementally emitted interned data, valid only on the packet's sequence
  // (packets with the same |trusted_packet_sequence_id|). The writer will
  // usually emit new interned data in the same TracePacket that first refers to
  // it (since the last reset of interning state). It may also be emitted
  // proactively in advance of referring to them in later packets.
  optional InternedData interned_data = 12;

  enum SequenceFlags {
    SEQ_UNSPECIFIED = 0;

    // Set by the writer to indicate that it will re-emit any incremental data
    // for the packet's sequence before referring to it again. This includes
    // interned data as well as periodically emitted data like
    // Process/ThreadDescriptors. This flag only affects the current packet
    // sequence (see |trusted_packet_sequence_id|).
    //
    // When set, this TracePacket and subsequent TracePackets on the same
    // sequence will not refer to any incremental data emitted before this
    // TracePacket. For example, previously emitted interned data will be
    // re-emitted if it is referred to again.
    //
    // When the reader detects packet loss (|previous_packet_dropped|), it needs
    // to skip packets in the sequence until the next one with this flag set, to
    // ensure intact incremental data.
    SEQ_INCREMENTAL_STATE_CLEARED = 1;

    // This packet requires incremental state, such as TracePacketDefaults or
    // InternedData, to be parsed correctly. The trace reader should skip this
    // packet if incremental state is not valid on this sequence, i.e. if no
    // packet with the SEQ_INCREMENTAL_STATE_CLEARED flag has been seen on the
    // current |trusted_packet_sequence_id|.
    SEQ_NEEDS_INCREMENTAL_STATE = 2;
  };
  optional uint32 sequence_flags = 13;

  // DEPRECATED. Moved to SequenceFlags::SEQ_INCREMENTAL_STATE_CLEARED.
  optional bool incremental_state_cleared = 41;

  // Default values for fields of later TracePackets emitted on this packet's
  // sequence (TracePackets with the same |trusted_packet_sequence_id|).
  // It must be reemitted when incremental state is cleared (see
  // |incremental_state_cleared|).
  // Requires that any future packet emitted on the same sequence specifies
  // the SEQ_NEEDS_INCREMENTAL_STATE flag.
  // TracePacketDefaults always override the global defaults for any future
  // packet on this sequence (regardless of SEQ_NEEDS_INCREMENTAL_STATE).
  optional TracePacketDefaults trace_packet_defaults = 59;

  // Flag set by the service if, for the current packet sequence (see
  // |trusted_packet_sequence_id|), either:
  // * this is the first packet, or
  // * one or multiple packets were dropped since the last packet that the
  //   consumer read from the sequence. This can happen if chunks in the trace
  //   buffer are overridden before the consumer could read them when the trace
  //   is configured in ring buffer mode.
  //
  // When packet loss occurs, incrementally emitted data (including interned
  // data) on the sequence should be considered invalid up until the next packet
  // with SEQ_INCREMENTAL_STATE_CLEARED set.
  optional bool previous_packet_dropped = 42;

  // Flag set by a producer (starting from SDK v29) if, for the current packet
  // sequence (see |trusted_packet_sequence_id|), this is the first packet.
  //
  // This flag can be used for distinguishing the two situations when
  // processing the trace:
  // 1. There are no prior events for the sequence because of data loss, e.g.
  //    due to ring buffer wrapping.
  // 2. There are no prior events for the sequence because it didn't start
  //    before this packet (= there's definitely no preceding data loss).
  //
  // Given that older SDK versions do not support this flag, this flag not
  // being present for a particular sequence does not necessarily imply data
  // loss.
  optional bool first_packet_on_sequence = 87;

  // The machine ID for identifying trace packets in a multi-machine tracing
  // session. Is emitted by the tracing service for producers running on a
  // remote host (e.g. a VM guest). For more context: go/crosetto-vm-tracing.
  optional uint32 machine_id = 98;
}

// End of protos/perfetto/trace/trace_packet.proto

// Begin of protos/perfetto/trace/trace.proto

message Trace {
  repeated TracePacket packet = 1;

  // Do NOT add any other field here. This is just a convenience wrapper for
  // the use case of a trace being saved to a file. There are other cases
  // (streaming) where TracePacket are directly streamed without being wrapped
  // in a Trace proto. Nothing should ever rely on the full trace, all the
  // logic should be based on TracePacket(s).
}

// End of protos/perfetto/trace/trace.proto